Tài liệu kỹ thuật: detector_rtsp.py, mapper_worker.py, queue_store.py

1) detector_rtsp.py
----------------------------------------
Mục tiêu
- Đọc luồng video RTSP, chạy suy luận YOLO cho từng frame, xuất kết quả phát hiện (per-frame) vào queue `raw_detection` (key = camera_id).

Luồng hoạt động
- Khởi tạo YOLO từ file model (mặc định: yolo11s_candy_model.pt).
- Mở kết nối RTSP qua OpenCV (`cv2.VideoCapture`).
- Vòng lặp:
  - Đọc frame từ RTSP.
  - Áp dụng `frame_skip` nếu có (bỏ bớt frame để giảm tải).
  - Chạy `model.predict` với tham số `conf`, `device`, `imgsz`.
  - Chuyển đổi kết quả `r.boxes` thành danh sách detections: class_id, class_name, confidence, bbox_xyxy.
  - Đóng gói payload: {camera_id, frame_id, timestamp, detections[]}.
  - Ghi vào topic `raw_detection` (SQLiteQueue.publish).

Đầu vào/ra
- Input: RTSP URL, tham số CLI: --camera-id, --model-path, --conf, --device, --frame-skip.
- Output (queue `raw_detection`): JSON per frame chứa danh sách bbox.

Thuật toán/Chi tiết
- Sử dụng YOLO (ultralytics) để phát hiện object, bboxes ở dạng xyxy với confidence và class.
- Tên lớp lấy từ `model.model.names` hoặc `model.names` tùy phiên bản.
- Timestamp theo UTC ISO-8601 với hậu tố Z.

Xử lý lỗi & Khả năng chịu lỗi
- Nếu `VideoCapture` không mở được RTSP → raise lỗi rõ ràng.
- Nếu không đọc được frame tạm thời → ngủ 0.2s và thử lại (không dừng).

Hiệu năng
- `frame_skip` cho phép giảm tần suất suy luận.
- Tham số `imgsz` đặt theo cạnh dài của frame để tối đa hóa độ chính xác trong giới hạn hiệu năng.


2) mapper_worker.py
----------------------------------------
Mục tiêu
- Worker tiêu thụ `raw_detection` (per-frame) và `roi_config` (per-camera), map bbox vào các ROI đã định nghĩa, tính occupancy score cho từng ROI với cơ chế debounce (EMA), publish kết quả (topic `roi_occupancy`) và hiển thị overlay trực quan.

Luồng hoạt động
- Khởi tạo kết nối queue (SQLiteQueue) và mở RTSP để hiển thị video thật thời gian.
- Đọc cấu hình ROI mới nhất theo `camera_id` (ưu tiên bản ghi mới hơn qua `get_after_id`, nếu không có thì dùng `get_latest_row`).
- Lấy các detection mới (batched) từ `raw_detection` theo `id` tăng dần (anti-dup bằng `last_det_id`).
- Với mỗi payload detections:
  - Đọc 1 frame video hiện tại (không đồng bộ tuyệt đối với frame_id nhưng đủ cho giám sát trực quan).
  - Tính điểm occupancy từng ROI: duyệt từng bbox, kiểm tra tâm bbox có nằm trong polygon ROI không; nếu có, tính IoU (ước lượng bằng mask) giữa polygon và bbox; ghi nhận điểm lớn nhất trên mỗi ROI.
  - Debounce bằng EMA: score_t = alpha*current + (1-alpha)*score_{t-1}.
  - Publish kết quả vào topic `roi_occupancy` với {camera_id, frame_id, timestamp, occupancy[]}.
  - Vẽ overlay: ROI kèm score, bbox và label; phím ESC để thoát.

Đầu vào/ra
- Input: queue `raw_detection`, queue `roi_config`, RTSP URL cùng camera_id.
- Output: queue `roi_occupancy` (key theo camera_id) và cửa sổ overlay.

Thuật toán chính
- Điểm ROI (occupancy_score):
  - Lọc bbox bằng điều kiện tâm hộp nằm trong polygon ROI (dùng `cv2.pointPolygonTest`).
  - Với bbox đủ điều kiện, tính giao nhau bằng mask nhị phân:
    - Tạo mask polygon và mask rectangle (bbox) trong cùng tọa độ ảnh.
    - `inter = sum(mask & box_mask)`; `box_area = (x2-x1)*(y2-y1)`.
    - `score = inter / box_area`. Lấy max trên các bbox cho mỗi ROI.
  - Lý do: phép xấp xỉ đơn giản, ổn định và đủ nhanh cho thực nghiệm.
- Debounce (EMA):
  - Trạng thái EMA riêng cho từng ROI (slot_id). Nếu chưa khởi tạo, lấy giá trị đầu tiên, ngược lại áp dụng `state = alpha*new + (1-alpha)*old`.
  - Tham số `--alpha` điều chỉnh độ mượt (càng nhỏ càng mượt nhưng trễ).

Tham số CLI
- --alpha: hệ số EMA (0..1), mặc định 0.3.
- --iou-threshold: ngưỡng để tô màu ROI coi là occupied trên overlay (mặc định 0.3).

Hiệu năng & Lưu ý
- Đọc theo lô nhỏ (limit=5) để giảm độ trễ và dao động.
- Map theo tâm hộp giúp cắt giảm số lần tính IoU đắt đỏ.
- IoU bằng mask phụ thuộc kích thước frame; mã hiện tại dùng không gian ảnh trực tiếp từ bbox (x1..x2, y1..y2) để giảm kích thước mask cần thiết.

Giới hạn
- Không đồng bộ cứng frame giữa detector và overlay (chấp nhận lệch nhẹ cho mục đích giám sát).
- IoU mask là ước lượng, không phải tính toán hình học chính xác tuyệt đối, nhưng đủ thực dụng.


3) queue_store.py (SQLiteQueue)
----------------------------------------
Mục tiêu
- Cung cấp hàng đợi nhẹ dùng SQLite để publish/consume message theo topic + key (ở đây key = camera_id).

Thiết kế & Bảng dữ liệu
- Bảng `messages(id INTEGER PK AUTOINCREMENT, topic TEXT, key TEXT, payload TEXT, created_at TEXT)`.
- Index: `idx_messages_topic_key_time` trên (topic, key, created_at) để tăng tốc truy vấn.

API chính
- publish(topic, key, payload: Dict):
  - Ghi 1 dòng vào `messages` với payload JSON và timestamp UTC.
- get_latest(topic, key) -> Dict | None:
  - Trả payload mới nhất cho topic/key.
- get_latest_row(topic, key) -> {id, payload, created_at} | None:
  - Như trên nhưng kèm `id` phục vụ đồng bộ consumer.
- get_after_id(topic, key, after_id, limit=50) -> List[{id, payload, created_at}]:
  - Lấy các bản ghi có id > after_id theo thứ tự tăng dần, giới hạn số lượng.

Tính chất
- Đảm bảo an toàn luồng (thread-safe) mức cơ bản bằng Lock quanh thao tác ghi.
- Bật WAL và synchronous=NORMAL để cải thiện hiệu năng ghi/đọc đồng thời.

Ưu/Nhược
- Ưu: Dễ triển khai, không cần hạ tầng ngoài, thông điệp bền vững (persisted).
- Nhược: Không phải message broker phân tán; phù hợp môi trường máy đơn, throughput vừa phải.

Khuyến nghị sử dụng
- Mỗi topic+key được tiêu thụ bởi 1 hoặc vài worker nhẹ; dùng `get_after_id` để đọc tăng dần và tránh trùng lặp.
- Định kỳ vacuum/backup nếu dữ liệu lớn dần theo thời gian.


